Overview
********
Parsing Expression Grammar (PEG) for when Regular Expressions just aren't enough!

Pegger is a [Parsing Expression Grammar (PEG)]`http://pdos.csail.mit.edu/~baford/packrat/popl04/peg-popl04.pdf` implementation. It lets you create text parsers by building up a tree of simple matching [rules]`Rules`.

Advanced parsing options let you *look ahead* with predicates and the returned tree of match results gives you plenty of options for transforming it into useful data.

Pegger was inspired by [Mouse]`http://www.romanredz.se/papers/CSP2009.Mouse.pdf` and [Parboiled]`https://github.com/sirthias/parboiled/wiki`.



Quick Start
***********
pre>
syntax: fantom
using afPegger::Peg

class Example {
    Void main() {
        input := "<<<Hello Mum>>>"
        rule  := "'<'+ name:[a-zA-Z ]+ '>'+"
        match := Peg(input, rule).match

        name  := match["name"]    // --> "Hello Mum"
    }
}
<pre



Usage
*****
The quick start example saw a lot of crazy symbols... so woah, what just happened?



Rules
=====
Pegger attempts to match a 'rule' against a given string. In the example the string was '<<<Hello Mum>>>' and the rule was that mixed bag of crazy characters. Rules can be written in PEG notation (see mixed bag of crazy characters) or they can be created programmatically via Fantom code using the `Rules` mixin:

pre>
syntax: fantom
// PEG Notation:
// '<'+ ([a-zA-Z] / " ")+ '>'+

// Fantom code:
rule := sequence { oneOrMore(char('<')), oneOrMore(firstOf { alphaChar, spaceChar }), oneOrMore(char('>')), }

<pre

The Fantom code can be a lot simplier to read and understand, but is also a lot more verbose.

Once you run a match, the result is a tree. Use 'Match.dump()' to see it:

pre>
syntax: fantom
rule := sequence { oneOrMore(char('<')), oneOrMore(firstOf { alphaChar, spaceChar }), oneOrMore(char('>')), }

input := "<<<Hello Mum>>>"
match := Peg(input, rule).match
match.dump

// --> root : "<<<Hello Mum>>>"

<pre

Okay, so that's not much of a tree. To create a tree, we need to give parts of our rule a label, or a name:

pre>
syntax: fantom
rule := sequence {
  oneOrMore(char('<')).withName("start"),
  oneOrMore(firstOf { alphaChar, spaceChar }).withName("name"),
  oneOrMore(char('>')).withName("end"),
}
<pre

We can do the same in PEG notation by using a 'label:' prefix:

pre>
rule := "start:'<'+ name:[a-zA-Z ]+ end:'>'+"
<pre

'match.dump()' now gives:

pre>
root
 ├─ start : "<<<"
 ├─ name : "Hello Mum"
 └─ end : ">>>"
<pre

Each part of the match may be retreived using the 'Match.get()' operator:

pre>
match["start"].toStr  // -> "<<<"
match["name"].toStr   // -> "Hello Mum"
match["end"].toStr    // -> ">>>"
<pre



Grammar
=======
The same could also be written as PEG grammar. Grammar defines multiple PEG rules. Grammars may be coded programmatically but are often created from a string. They need to define an overriding *root* rule which responsible matching everything:

pre>
root  <- start name end
start <- '<'+
name  <- [a-zA-Z ]+
end   <- '>'+
<pre

Each definition must be placed on its own line, and may also be written in a more standard property file notation using '=':

pre>
syntax: props
#  Hash comments are allowed in grammar
// as are double slash comments

root  = start name end
start = '<'+
name  = [a-zA-Z ]+
end   = '>'+
<pre

When run, the same result is given:

pre>
syntax: fantom

grammarStr := "..."
grammar    := Peg.parseGrammar(grammarStr)
rootRule   := grammar["root"]

match      := Peg(input, rootRule).match
match.dump
<pre

Once a grammar (or rule) has been parsed, it may be cached for future re-use.



Recursive / HTML Parsing
************************
A well known limitation of regular expressions is that they can not match nested patterns, such as HTML. (See [StackOverflow for explanation]`http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454`.)
Pegger to the rescue!

Because PEGs contain rules that may reference themselves in a circular fashion, it is possible to create recursive parsers.

Below is an example that parses nested HTML tags. You can see the recursion from the 'element' definition which references itself:

pre>
syntax: fantom
pegDefs := "element  = startTag (element / text)* endTag
            startTag = '<'  name:[a-z]i+ '>'
            endTag   = '</' name:[a-z]i+ '>'
            text     = [^<]+"
grammar := Peg.parseGrammar(pegDefs)
element := grammar["grammar"]

html := parseHtml("<html><head><title>Pegger Example</title></head><body><p>Parsing is Easy!</p></body></html>")

Peg(html, element).match.dump

<pre

Which outputs the following result tree:

pre>
element
 ├─ startTag
 │   └─ name : "html"
 ├─ element
 │   ├─ startTag
 │   │   └─ name : "head"
 │   ├─ element
 │   │   ├─ startTag
 │   │   │   └─ name : "title"
 │   │   ├─ text : "Pegger Example"
 │   │   └─ endTag
 │   │       └─ name : "title"
 │   └─ endTag
 │       └─ name : "head"
 ├─ element
 │   ├─ startTag
 │   │   └─ name : "body"
 │   ├─ element
 │   │   ├─ startTag
 │   │   │   └─ name : "p"
 │   │   ├─ text : "Parsing is Easy!"
 │   │   └─ endTag
 │   │       └─ name : "p"
 │   └─ endTag
 │       └─ name : "body"
 └─ endTag
     └─ name : "html"
<pre

Parsing has never been easier!

*Note that only **Chuck Norris** can parse HTML with regular expressions.*

Converting the match results into XML is left as an excerise for the user, but there are a couple of options open to you:



1. Looping
==========
This is usually the easiest way to convert your match results, but not always the cleanest.

It involves looping over the match results the same as you would with any other list, and recursively calling yourself to convert inner data.



2. Walking
==========
Create a 'walk()' method that recursively calls a given function every time it steps into, or out of, a match:

pre>
Void walk(Match match, |Match, Str startOrEnd| fn) {
    fn?.call(match, "start")
    m.matches.each { walk(it, fn) }
    fn?.call(match, "end")
}
<pre



3. Rule Actions
===============
You can add action functions to rules. Functions are called when the rule is successfully matched.

Note that action functions are only called once all matching has been completed. That way functions are not called when sequences are being explored, or before predicates are rolled back.

pre>
grammar["startTag"].withAction |tagName| { echo("startTag: $tagName") }
grammar["text"    ].withAction |text|    { echo("text: $text") }
grammar["endTag"  ].withAction |tagName| { echo("endTag: $tagName") }
<pre



Debugging
*********
By enabling debug logging, 'Pegger' will spew out a *lot* of debug / trace information. (Possiblly more than you can handle!)
But note it will only emit debug information for rules with names.

Enable debug logging with the line:

  syntax: fantom

  Peg.debugOn

  // or

  Log.get("afPegger").level = LogLevel.debug

Which, for the above html parsing example, will generate the following:

pre>
[afPegger] [  1] --> element - Processing: startTag (element / text)* endTag with: <html><title>Pegger Ex...
[afPegger] [  2]  --> startTag - Processing: "<" [a-zA-Z]+ ">" with: <html><title>Pegger Ex...
[afPegger] [  2]    > startTag - Passed!
[afPegger] [  2]    > startTag - Matched: "<html>"
[afPegger] [  4]    --> element - Processing: startTag (element / text)* endTag with: <title>Pegger Example<...
[afPegger] [  5]     --> startTag - Processing: "<" [a-zA-Z]+ ">" with: <title>Pegger Example<...
[afPegger] [  5]       > startTag - Passed!
[afPegger] [  5]       > startTag - Matched: "<title>"
[afPegger] [  7]       --> element - Processing: startTag (element / text)* endTag with: Pegger Example</title>...
[afPegger] [  8]        --> startTag - Processing: "<" [a-zA-Z]+ ">" with: Pegger Example</title>...
[afPegger] [  8]          > startTag - Did not match "<".
[afPegger] [  8]          > startTag - Failed. Rolling back.
[afPegger] [  7]         > element - Did not match startTag.
[afPegger] [  7]         > element - Failed. Rolling back.
[afPegger] [  7]       --> text - Processing: (!"<" .)+ with: Pegger Example</title>...
[afPegger] [  7]         > text - Rule was successfully processed 14 times
[afPegger] [  7]         > text - Passed!
[afPegger] [  7]         > text - Matched: "Pegger Example"
...
...
...
<pre

